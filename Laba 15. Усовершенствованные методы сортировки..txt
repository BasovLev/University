#include <stdio.h>
#include <stdlib.h>
#define SIZE 20
int N, key1=0; 
void Pr(int*, int);
void merge(int* ,int ,int ,int ,int );
void merge_sort(int*, int ,int );
int main()
{
  int m[SIZE], n;
  scanf ("%d", &n);
  N=n;
  for (int i = 0; i<n; i++) scanf ("%d", &m[i]);
  //Pr(m,N);
  merge_sort(m,0,n-1);
  //Pr(m,N);
  
  return 0;
}
void Pr (int *m, int n){
    for (int i = 0; i<n; i++) printf("%3d", i+1);
    printf("\n");
    for (int i = 0; i<n; i++) printf("%3d", m[i]);
    printf("\n\n");
}
void merge(int *a,int l,int r,int mid,int n){// Процесс «консолидации» слияния, объединения двух упорядоченных последовательностей в одну упорядоченную последовательность
// l-> индекс крайнего левого элемента, r-> индекс крайнего правого элемента, mid-> индекс среднего элемента, temp [] - временный массив, n - длина [] 
	int temp[n];
	int i=l;// Указатель левой последовательности 
	int j=mid+1;// Правый указатель последовательности 
	int k=0;// Указатель временного массива 
	while(i<=mid&&j<=r){
		if(a[i]<=a[j])
			temp[k++]=a[i++];
		else
			temp[k++]=a[j++];
	}
	while(i<=mid){// Заполняем оставшиеся элементы слева в temp 
		temp[k++]=a[i++];
	}
	while(j<=r){// Заполняем оставшиеся элементы справа в temp
		temp[k++]=a[j++];
	}
	k=0;
	// Копируем все элементы в temp в исходный массив
	while(l<=r)
		a[l++]=temp[k++];
}
void merge_sort(int *a,int l,int r){// Сортировка слиянием, процесс «разделяй и властвуй», рекурсивная реализация
	if(l>=r)// Убедитесь, что l - слева, r - справа n - длина a [] 
	return ;
	
	int mid=(l+r)/2;
	// Разделим последовательность на две последовательности и сортируем их по отдельности 
	merge_sort(a,l,mid);// Объединить и отсортировать левую часть, чтобы упорядочить левую подпоследовательность 
	merge_sort(a,mid+1,r);// Слияние и сортировка справа для создания правильной подпоследовательности по порядку
	merge(a,l,r,mid,r-l+1);// Объединение двух упорядоченных подпоследовательностей 
	if(key1!=0)Pr(a,N);
	key1=1;
}